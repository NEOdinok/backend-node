## Чем чревато использование в callbacks внутри watch() мутацию массивов (.push, .splice)? Как правильно?

**watch() отслеживает массив по ссылке.**

Мутации на месте (.push(), .splice() и т.д.) оставляют ссылку той же — **watch не сработает**.

**Правильно:** создавать **новый массив с изменениями** — тогда всё отработает.

---

## Как организовать управление состоянием между страницами в Nuxt 3 при помощи Composition API и не использовать Vuex / Pinia?

В Nuxt 3 действительно можно такое делать.

**Вкратце:**

1. Создаём `composables/useStoreName.ts`
2. При помощи `ref` / `reactive` создаём стейт и методы
3. Импортируем в любую страницу — **стейт общий**

**Важно:** речь про **SPA**. Если у нас **SSR**, тогда:

- использовать `useState()`
- думать, как класть в куки / localStorage

---

## Как в Vue 3 добиться реактивности вложенного объекта в TypeScript без использования reactive, если приходит ответ с сервера в виде глубокого JSON?

**Пример:**

1. Сделать глубокую копию:  
   `structuredClone(response)`  
   (или `cloneDeep` из lodash, если `structuredClone` не поддерживается)

2. Завернуть в `ref`:  
   `const data = ref(structuredClone(response))`

**P.S.**  
Делать всё типизированно:  
`const user = ref<ResponseType>(structuredClone(response))`

---

## Как при работе с Docker обеспечить, чтобы фронтенд-сборка под Nuxt включала только нужные переменные окружения?

- Не использовать `process.env` в `<script setup>`
- Использовать `useRuntimeConfig()` вместо `process.env`
- Хранить приватные ключи **без префикса `NUXT_PUBLIC_`**
- Использовать **multi-stage build**: разделять стадии `build` и `runtime`

---

## Как предотвратить повторный рендеринг дочернего компонента при обновлении пропсов, которые не влияют на его логику?

1. Передавать неважные данные через `$attrs`, не использовать их в шаблоне
2. Использовать `v-memo` (аналог `React.memo`)
3. Отключить проброс атрибутов:  
   `defineOptions({ inheritAttrs: false })`

---

## Как добиться pixel-perfect вёрстки, если дизайнер предоставил макет только для десктопа?

**Вообще, это плохой подход — нужно mobile-first.**

Если работаем с тем, что есть:

- использовать `flex`, `grid`, `@media` (`max-width`, `min-width`)
- желательно использовать **Tailwind** — адаптивность на классах, без ручного написания media-запросов

---

## Зачем в Tailwind применяют @layer и какие ограничения есть у этой директивы?

`@layer` говорит Tailwind:

> "Я добавляю кастомные стили, встрои их корректно, с учётом приоритетов и purge."

**Ограничения:**

- Нельзя вкладывать `@layer` внутрь селектора
- `@apply` работает только с классами внутри слоёв
- Tailwind должен знать об этом файле (прописан в `tailwind.config`)

---

## Почему при использовании useState в Nuxt 3 данные сбрасываются при переходе между страницами?

Если `useState()` используется **внутри setup компонента**, а не в `composables/`.

**Почему?**  
Компонент размонтируется → `useState()` заново создаётся → данные теряются

**Решение:** выносить `useState()` в `composables/`.

Также: проверьте **ключ** в `useState()` — должен быть стабильным и корректным.

---

## Как избежать дублирования кода в asyncData и onMounted при рендеринге данных на сервере и клиенте?

Использовать **`useAsyncData()` в setup()**, можно вынести в `composables`.

**Плюсы:**

- Работает и на сервере (SSR), и на клиенте (CSR)
- Автоматически кэшируется
- Не будет повторно вызван при повторном использовании

---

## Как обработать ситуацию, когда бэкенд возвращает 401 ошибку, но токен в localStorage есть?

**401 Unauthorized** — токен просрочен или невалиден, даже если есть в `localStorage`.

**Решение:**

1. Создать **composable для авторизации** и работы с токеном

2. Если есть refresh token:
   - Отправить запрос на `/refresh`
   - Успешно? → сохранить новый access token
   - Повторить оригинальный запрос
   - Неуспешно? → удалить токен и отправить на `/login`
